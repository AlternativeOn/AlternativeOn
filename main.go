//Version: 0.0.7 (Beta 7)
package main

import (
	"fmt"
	"strings"
	"time"

	"github.com/alternativeon/pgo"
	"github.com/gonutz/w32/v2"
	"github.com/mattn/go-colorable"
	"github.com/rs/zerolog"
	llgg "github.com/rs/zerolog/log"
	"golang.org/x/sys/windows/registry"

	"github.com/andlabs/ui"
	_ "github.com/andlabs/ui/winmanifest"
	"github.com/ncruces/zenity"
)

/*type Token struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
	ExpiresIn    int    `json:"expires_in"`
	TokenType    string `json:"token_type"`
}*/

type AutoGenerated []struct {
	ID       string      `json:"id"`
	Nome     string      `json:"nome"`
	Cor      string      `json:"cor"`
	Ordem    int         `json:"ordem"`
	Ativo    bool        `json:"ativo"`
	Solucoes []Solutions `json:"solucoes"`
}
type Solutions struct {
	ID               string `json:"id"`
	Nome             string `json:"nome"`
	Descricao        string `json:"descricao"`
	Arquivo          string `json:"arquivo"`
	Link             string `json:"link"`
	Ativo            bool   `json:"ativo"`
	TipoRenderizacao string `json:"tipoRenderizacao"`
	Slug             string `json:"slug"`
	Ordem            int    `json:"ordem"`
	DataCadastro     string `json:"dataCadastro"`
	Novo             bool   `json:"novo"`
}

type Error struct {
	Error            string `json:"error"`
	ErrorDescription string `json:"error_description"`
}

var mainwin *ui.Window
var Usertoken string
var Username string
var start time.Time
var version = "0.0.8"

func init() {
	//Configuração do logger
	logOutput := colorable.NewColorableStdout()
	llgg.Logger = llgg.Output(zerolog.ConsoleWriter{Out: logOutput})
	start = time.Now()
	//Verifica no registro se o log deve ficar visivel
	cfg, err := verificarConfigDebug()
	if err != nil || cfg == -1 {
		llgg.Warn().Str("Erro", err.Error()).Msg("Não foi possível verificar a configuração.")
	}
	if cfg == 1 {
		//1 esconde o terminal
		console := w32.GetConsoleWindow()
		if console != 0 {
			_, consoleProcID := w32.GetWindowThreadProcessId(console)
			if w32.GetCurrentProcessId() == consoleProcID {
				w32.ShowWindowAsync(console, w32.SW_HIDE)
			}
		}
	}
	llgg.Trace().Str("Valor", fmt.Sprint(cfg)).Msg("Configuração Terminal:")
}

func loginPage() ui.Control {
	//Cria a UI de login
	vbox := ui.NewVerticalBox()
	vbox.SetPadded(true)
	vbox.Append(ui.NewLabel("Para começarmos, faça seu login. Use o usuário e senha do Positivo On"), false)
	vbox.Append(ui.NewVerticalSeparator(), false)

	group := ui.NewGroup("Login")
	group.SetMargined(true)
	vbox.Append(group, true)

	aboutform := ui.NewForm()
	aboutform.SetPadded(true)
	group.SetChild(aboutform)

	//aboutform.Append("Usuário", ui.NewEntry(), false)
	user := ui.NewEntry()
	user.SetText("")
	aboutform.Append("Usuário", user, false)
	pass := ui.NewPasswordEntry()
	pass.SetText("")
	aboutform.Append("Senha", pass, false)
	loginButton := ui.NewButton("Entrar")
	loginButton.OnClicked(func(*ui.Button) {
		//disable button
		loginButton.Disable()
		//get user and password
		user := user.Text()
		pass := pass.Text()
		//check if user and password are empty
		if user == "" || pass == "" {
			llgg.Error().Msg("Usuário tentou fazer login sem preencher os dados necessários.")
			//error message
			ui.MsgBoxError(mainwin, "Preencha todos os campos", "O campo de usuário e senha não podem ser vazios.")
			loginButton.Enable()
			return
		}
		//do login
		llgg.Trace().Msg("Iniciando login...")

		usrtoken, err := pgo.Login(user, pass)
		if err != nil {
			llgg.Error().Str("Detalhes", err.Error()).Msg("Erro ao fazer login!")
			ui.MsgBoxError(mainwin, "Erro ao realizar a autenticação!", err.Error())
			loginButton.Enable()
			return
		}
		Usertoken = usrtoken
		llgg.Info().Msg("Login realizado com sucesso!")
		llgg.Trace().Msg("Tentando pegar as informações do usuário...")
		username, err := pgo.GetUserName(Usertoken)
		if err != nil {
			llgg.Error().Str("Erro", err.Error()).Msg("Problema ao obter o nome do usuário!")
		}
		//Corta o nome do usuário, mostrando apenas o primeiro nome
		Username = strings.Split(username, " ")[0]
		llgg.Trace().Str("Nome do usuário", Username).Msg("Nome obtido com sucesso!")
		//Vai para a página apos o login
		mainwin.Destroy()
		mostrarUiAposLogin()
		ui.Quit()

	})
	aboutform.Append("", loginButton, false)

	return vbox
}

func aboutPage() ui.Control {
	//Create an about window on a vertical box
	vbox := ui.NewVerticalBox()
	vbox.SetPadded(true)
	vbox.Append(ui.NewLabel("Aqui você pode saber sobre o projeto Alternative On."), false)
	vbox.Append(ui.NewVerticalSeparator(), false)

	group := ui.NewGroup("Sobre o Alternative On")
	group.SetMargined(true)
	vbox.Append(group, true)

	aboutform := ui.NewForm()
	aboutform.SetPadded(true)
	group.SetChild(aboutform)

	//Sobre o aplicativo, na página principal
	abouttext := ui.NewMultilineEntry()
	abouttext.SetReadOnly(true)
	abouttext.SetText("Este é um cliente alternativo ao Positivo On, ele foi desenvolvido para facilitar o uso da plataforma, e ainda está na fase beta.\n\nO projeto é mantido pelo grupo de desenvolvimento da Princess Mortix, e é um projeto open source, você pode acessar o projeto no github clicando no botão abaixo.\nCaso você queira contribuir com o projeto, você pode acessar o github você pode enviar um issue, ou se preferir, você pode enviar um pull request diretamente no github.\n\nObrigado por usar o Alternative On!\n\n**Politica de Privacidade:**\nNós não coletamos nenhum dado de você, mas talvez a plataforma Positivo On, que é um serviço de terceiros, coleta dados de usuários.")
	aboutform.Append("", abouttext, true)
	//Botão com o link pro GitHub
	ghlink := ui.NewButton("Acessar o projeto no GitHub")
	ghlink.OnClicked(func(*ui.Button) {
		//Abre a página
		err := w32.ShellExecute(0, "open", "https://github.com/PrincessMortix/AlternativeOn", "", "", w32.SW_SHOW)
		if err != nil {
			llgg.Error().Str("Erro", err.Error()).Msg("Não foi possivel abrir o link!")
		}
	})
	terms := ui.NewButton("Termos do Positivo On")
	terms.OnClicked(func(*ui.Button) {
		//Abre a página
		err := w32.ShellExecute(0, "open", "https://positivoon.com.br/#/termos-de-uso", "", "", w32.SW_SHOW)
		if err != nil {
			llgg.Error().Str("Erro", err.Error()).Msg("Não foi possivel abrir o link!")
		}
	})
	privacy := ui.NewButton("Política de Privacidade do Positivo On")
	privacy.OnClicked(func(*ui.Button) {
		//também abre a página
		err := w32.ShellExecute(0, "open", "https://positivoon.com.br/#/politica-de-privacidade", "", "", w32.SW_SHOW)
		if err != nil {
			llgg.Error().Str("Erro", err.Error()).Msg("Não foi possivel abrir o link!")
		}
	})
	aboutform.Append("", terms, false)
	aboutform.Append("", privacy, false)
	aboutform.Append("", ghlink, false)

	return vbox
}

func settingsPage() ui.Control {
	//Cria a janela de configurações
	vbox := ui.NewVerticalBox()
	vbox.SetPadded(true)
	vbox.Append(ui.NewLabel("Aqui você pode alterar o funcionamento do Alternative On"), false)
	vbox.Append(ui.NewVerticalSeparator(), false)

	group := ui.NewGroup("Configurações disponíveis")
	group.SetMargined(true)
	vbox.Append(group, true)

	//Texto explicativo fica por aqui, seta pra baixo
	settingsForm := ui.NewForm()
	settingsForm.SetPadded(true)
	group.SetChild(settingsForm)

	settingsText := ui.NewMultilineEntry()
	settingsText.SetReadOnly(true)
	settingsText.SetText("Ajuda das configurações:\n\n- Mostrar terminal de depuração (Essa configuração mostra o terminal, mostrando sobre possiveis erros da aplicação)\n\n- Abrir links no navegador padrão (Essa configuração permite que alguns links sejam abertos no seu navegador preferido, ao invez de usar o navegador embutido na aplicação. Note que o navegador embutido requer uma instalação adicional de recursos na máquina.)")
	settingsForm.Append("", settingsText, true)

	settingsShowDebug := ui.NewCheckbox("Mostrar terminal de depuração")
	valor, err := verificarConfigDebug()
	if err != nil || valor == -1 {
		llgg.Warn().Str("Erro", err.Error()).Msg("Não foi possível verificar a configuração.")
	}
	if valor == 0 {
		settingsShowDebug.SetChecked(true)
	}
	settingsShowDebug.OnToggled(func(*ui.Checkbox) {
		if settingsShowDebug.Checked() {
			llgg.Info().Msg("O terminal foi configurado para ficar ativo.")
			//Configura o terminal pra mostrar as mensagens de debug
			setTerminal, err := registry.OpenKey(registry.CURRENT_USER, `Software\Princess Mortix\Alternative On`, registry.SET_VALUE)
			if err != nil {
				ui.MsgBoxError(mainwin, "Erro", "Erro ao criar configuração para o terminal: "+err.Error()+"\nTente abrir a aplicação novamente como administrador.")
				llgg.Fatal().Str("Erro", err.Error()).Msg("Erro grave ao criar a configuração para o terminal! O programa irá sair agora...")
			}
			err = setTerminal.SetDWordValue("HideCmd", 0)
			if err != nil {
				ui.MsgBoxError(mainwin, "Erro", "Erro ao configurar o terminal: "+err.Error()+"\nTente abrir a aplicação novamente como administrador.")
				llgg.Fatal().Str("Erro", err.Error()).Msg("Erro grave ao criar a configuração para o terminal! O programa irá sair agora...")
			}
		} else {
			llgg.Info().Msg("O terminal foi configurado para ficar inativo.")
			//Configura o terminal pra esconder as mensagens de debug
			setTerminal, err := registry.OpenKey(registry.CURRENT_USER, `Software\Princess Mortix\Alternative On`, registry.SET_VALUE)
			if err != nil {
				ui.MsgBoxError(mainwin, "Erro", "Erro ao criar configuração para o terminal: "+err.Error()+"\nTente abrir a aplicação novamente como administrador.")
				llgg.Fatal().Str("Erro", err.Error()).Msg("Erro grave ao criar a configuração para o terminal! O programa irá sair agora...")
			}
			err = setTerminal.SetDWordValue("HideCmd", 1)
			if err != nil {
				ui.MsgBoxError(mainwin, "Erro", "Erro ao configurar o terminal: "+err.Error()+"\nTente abrir a aplicação novamente como administrador.")
				llgg.Fatal().Str("Erro", err.Error()).Msg("Erro grave ao criar a configuração para o terminal! O programa irá sair agora...")
			}
		}
	})
	settingsForm.Append("", settingsShowDebug, false)

	return vbox
}

func setupUI() {
	mainwin = ui.NewWindow("Alternative On", 640, 480, true)
	mainwin.OnClosing(func(*ui.Window) bool {
		ui.Quit()
		return true
	})
	ui.OnShouldQuit(func() bool {
		mainwin.Destroy()
		return true
	})

	tab := ui.NewTab()
	mainwin.SetChild(tab)
	mainwin.SetMargined(true)

	tab.Append("Inicio", loginPage())
	tab.SetMargined(0, true)
	tab.Append("Sobre", aboutPage())
	tab.SetMargined(1, true)
	tab.Append("Configurações", settingsPage())
	tab.SetMargined(2, true)

	mainwin.Show()
}

func main() {
	llgg.Info().Str("Tempo", fmt.Sprint(time.Since(start))).Msg("Inicialização completa.")
	zenity.Warning("Note que este é um cliente alternativo ao Positivo On EM FASE DE TESTES, e que bugs podem ocorrer eventualmente.", zenity.Title("Atenção"), zenity.WarningIcon)
	ui.Main(setupUI)
}

func verificarConfigDebug() (int, error) {
	k, err := registry.OpenKey(registry.CURRENT_USER, `Software\Princess Mortix\Alternative On`, registry.QUERY_VALUE)
	if err != nil {
		return -1, err
	}
	defer k.Close()
	configEsconderDebug, _, err := k.GetIntegerValue("HideCmd")
	if err != nil {
		llgg.Info().Msg("A configuração do terminal não foi criada, criando a configuração...")
		setKey, err := registry.OpenKey(registry.CURRENT_USER, `Software\Princess Mortix\Alternative On`, registry.SET_VALUE)
		if err != nil {
			llgg.Warn().Msg("Erro ao criar configuração para o terminal:" + err.Error() + "\nContinuando mesmo assim...")
		}
		err = setKey.SetDWordValue("HideCmd", 1)
		if err != nil {
			llgg.Warn().Msg("Erro ao configurar o terminal:" + err.Error() + "\nContinuando mesmo assim...")
		}
	}
	k.Close()
	return int(configEsconderDebug), nil
}
